import asyncio
import logging
import os
from contextlib import asynccontextmanager
from typing import AsyncGenerator, Any

import redis.asyncio as redis
from redis.asyncio import Redis

from core.server_core.state_capture import checkpoint
from core.server_core.state_manager.session import Session

REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = os.getenv("REDIS_PORT", 6379)
REDIS_USER = os.getenv("REDIS_USER", "default")
REDIS_PASS = os.getenv("REDIS_PASS", "")
POOL_SIZE = 6
TIMEOUT = 10
TIME_TO_LIVE = 300

logger = logging.getLogger(__name__)

class SessionMesh:
    def __init__(self):
        self.connection_pool = redis.BlockingConnectionPool(
            host = REDIS_HOST,
            port = REDIS_PORT,
            username = REDIS_USER,
            password = REDIS_PASS,
            max_connections=POOL_SIZE,
            db = 0,
            timeout=TIMEOUT)

    @asynccontextmanager
    async def get_redis_client(self) -> AsyncGenerator[Redis, Any]:
        client = redis.Redis(connection_pool=self.connection_pool)
        try:
            yield client
        finally:
            await client.aclose()


    async def get_parent(self, name):
        """
        Retrieve the parent of a mesh by its name.

        This method interacts with a Redis database to fetch the parent of a given mesh.
        It checks if the mesh is closed and returns None if it is closed, otherwise it returns the parent.

        Args:
            name (str): The name of the mesh. name is the keyspace which is randomly generated by the server.

        Returns:
            str or None: The parent of the mesh if it is not closed, otherwise None.

        Raises:
            redis.RedisError: If there is an error while interacting with Redis.
        """
        try:
            async with self.get_redis_client() as client:
                async with client.pipeline(transaction=True) as pipe:
                    await pipe.get(f"mesh:{name}:parent")
                    await pipe.get(f"mesh:{name}:closed")
                    parent, closed = await pipe.execute()
                    if closed:
                        return None
                    return parent
        except redis.RedisError as e:
            logger.exception(f"Redis Error in get_owner: {e}")
            return None

    async def get_session(self, name):
        try:
            async with self.get_redis_client() as client:
                async with client.pipeline(transaction=True) as pipe:
                    await pipe.get(f"mesh:{name}:parent")
                    await pipe.get(f"mesh:{name}:checkpoint_session")
                    await pipe.get(f"mesh:{name}:closed")
                    parent, session, closed = await pipe.execute()
                    if closed:
                        return [None, None]
                    return [parent, session]
        except redis.RedisError as e:
            logger.exception(f"Redis Error in get_session: {e}")
        return None

    async def periodic_session_sync(self, name: str, session: Session):
        """
        Periodically syncs the session state to Redis.

        This method runs an infinite loop that waits for either 30 seconds,
        a session sync event, or a session termination event, whichever occurs first.
        If the session is terminated, the loop exits. Otherwise, it captures the
        current session state and stores it in Redis with a TTL (Time To Live) of 5 minutes.

        Args:
            name (str): The name of the mesh.
            session (Session): The session object to be synced.

        Raises:
            redis.RedisError: If there is an error while interacting with Redis.
        """
        while True:
            done, pending = await asyncio.wait([
                asyncio.create_task(asyncio.sleep(30)),
                asyncio.create_task(session.sync_now_wait()),
                asyncio.create_task(session.terminated())
            ], return_when=asyncio.FIRST_COMPLETED)

            if done.pop().result() == "terminated":
                return

            checkpoint_session = await checkpoint.checkpoint_capture(session)
            try:
                async with self.get_redis_client() as client:
                    async with client.pipeline(transaction=True) as pipe: # type: redis.Redis.pipeline
                        await pipe.setex(name=f"mesh:{name}:checkpoint_session", value=checkpoint_session, time= TIME_TO_LIVE)
                        await pipe.setex(name=f"mesh:{name}:parent", value=session.metadata.name, time=TIME_TO_LIVE)
                        await pipe.execute()
            except redis.RedisError as e:
                logger.exception(f"Redis Error in periodic_session_sync: {e}")
                continue


    async def broadcast_transfer(self, name: str):
        async with self.get_redis_client() as client:
            await client.publish(f"broadcasts", name)


    async def mark_closed(self, name: str):
        async with self.get_redis_client() as client:
            async with client.pipeline(transaction=True) as pipe:
                await pipe.delete(f"mesh:{name}:checkpoint_session")
                await pipe.delete(f"mesh:{name}:parent")
                await pipe.setex(name=f"mesh:{name}:closed",value=True, time=TIME_TO_LIVE)

        await self.broadcast_transfer(name=name)



    @staticmethod
    async def subscribe_transfers() -> AsyncGenerator[str]:
        redis_conn: redis.Redis | None = None
        while True:
            try:
                # Create a standalone Redis connection
                redis_conn: redis.Redis = redis.Redis(
                    host=REDIS_HOST,
                    port=REDIS_PORT,
                    username=REDIS_USER,
                    password=REDIS_PASS,
                    db=0,
                    decode_responses=True)

                # Create a Pub/Sub object
                pubsub: redis.client.PubSub = redis_conn.pubsub()

                # Subscribe to a channel
                await pubsub.subscribe('broadcasts')

                # Listen for new messages and Yield messages to the caller
                async for message in pubsub.listen():
                    if message['type'] == 'message':
                        yield message['data']  # Yield each message to the caller
            except redis.RedisError as e:
                logger.exception(f"Redis Error in subscribe_transfers: {e}")
                continue

        if redis_conn:
            await redis_conn.aclose()


